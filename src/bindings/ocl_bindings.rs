/* automatically generated by rust-bindgen 0.71.1 */

use crate::*;

pub const CL_TARGET_OPENCL_VERSION: u32 = 120;
pub const CL_VERSION_1_2: u32 = 1;
pub const CL_VERSION_1_1: u32 = 1;
pub const CL_VERSION_1_0: u32 = 1;
pub const CL_CHAR_BIT: u32 = 8;
pub const CL_SCHAR_MAX: u32 = 127;
pub const CL_SCHAR_MIN: i32 = -128;
pub const CL_CHAR_MAX: u32 = 127;
pub const CL_CHAR_MIN: i32 = -128;
pub const CL_UCHAR_MAX: u32 = 255;
pub const CL_SHRT_MAX: u32 = 32767;
pub const CL_SHRT_MIN: i32 = -32768;
pub const CL_USHRT_MAX: u32 = 65535;
pub const CL_INT_MAX: u32 = 2147483647;
pub const CL_INT_MIN: i32 = -2147483648;
pub const CL_UINT_MAX: u32 = 4294967295;
pub const CL_FLT_DIG: u32 = 6;
pub const CL_FLT_MANT_DIG: u32 = 24;
pub const CL_FLT_MAX_10_EXP: u32 = 38;
pub const CL_FLT_MAX_EXP: u32 = 128;
pub const CL_FLT_MIN_10_EXP: i32 = -37;
pub const CL_FLT_MIN_EXP: i32 = -125;
pub const CL_FLT_RADIX: u32 = 2;
pub const CL_FLT_MAX: f64 = 340282346638528860000000000000000000000.0;
pub const CL_HALF_DIG: u32 = 3;
pub const CL_HALF_MANT_DIG: u32 = 11;
pub const CL_HALF_MAX_10_EXP: u32 = 4;
pub const CL_HALF_MAX_EXP: u32 = 16;
pub const CL_HALF_MIN_10_EXP: i32 = -4;
pub const CL_HALF_MIN_EXP: i32 = -13;
pub const CL_HALF_RADIX: u32 = 2;
pub const CL_HALF_MAX: f64 = 65504.0;
pub const CL_DBL_DIG: u32 = 15;
pub const CL_DBL_MANT_DIG: u32 = 53;
pub const CL_DBL_MAX_10_EXP: u32 = 308;
pub const CL_DBL_MAX_EXP: u32 = 1024;
pub const CL_DBL_MIN_10_EXP: i32 = -307;
pub const CL_DBL_MIN_EXP: i32 = -1021;
pub const CL_DBL_RADIX: u32 = 2;
pub const CL_DBL_MAX : f64 = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const CL_M_E: f64 = 2.718281828459045;
pub const CL_M_LOG2E: f64 = 1.4426950408889634;
pub const CL_M_LOG10E: f64 = 0.4342944819032518;
pub const CL_M_LN2: f64 = 0.6931471805599453;
pub const CL_M_LN10: f64 = 2.302585092994046;
pub const CL_M_PI: f64 = 3.141592653589793;
pub const CL_M_PI_2: f64 = 1.5707963267948966;
pub const CL_M_PI_4: f64 = 0.7853981633974483;
pub const CL_M_1_PI: f64 = 0.3183098861837907;
pub const CL_M_2_PI: f64 = 0.6366197723675814;
pub const CL_M_2_SQRTPI: f64 = 1.1283791670955126;
pub const CL_M_SQRT2: f64 = 1.4142135623730951;
pub const CL_M_SQRT1_2: f64 = 0.7071067811865476;
pub const CL_M_E_F: f64 = 2.718281828;
pub const CL_M_LOG2E_F: f64 = 1.442695041;
pub const CL_M_LOG10E_F: f64 = 0.434294482;
pub const CL_M_LN2_F: f64 = 0.693147181;
pub const CL_M_LN10_F: f64 = 2.302585093;
pub const CL_M_PI_F: f64 = 3.141592654;
pub const CL_M_PI_2_F: f64 = 1.570796327;
pub const CL_M_PI_4_F: f64 = 0.785398163;
pub const CL_M_1_PI_F: f64 = 0.318309886;
pub const CL_M_2_PI_F: f64 = 0.636619772;
pub const CL_M_2_SQRTPI_F: f64 = 1.128379167;
pub const CL_M_SQRT2_F: f64 = 1.414213562;
pub const CL_M_SQRT1_2_F: f64 = 0.707106781;
pub const CL_MAXFLOAT: f64 = 340282346638528860000000000000000000000.0;
pub const CL_HAS_NAMED_VECTOR_FIELDS: u32 = 1;
pub const CL_HAS_HI_LO_VECTOR_FIELDS: u32 = 1;
pub const CL_SUCCESS: u32 = 0;
pub const CL_DEVICE_NOT_FOUND: i32 = -1;
pub const CL_DEVICE_NOT_AVAILABLE: i32 = -2;
pub const CL_COMPILER_NOT_AVAILABLE: i32 = -3;
pub const CL_MEM_OBJECT_ALLOCATION_FAILURE: i32 = -4;
pub const CL_OUT_OF_RESOURCES: i32 = -5;
pub const CL_OUT_OF_HOST_MEMORY: i32 = -6;
pub const CL_PROFILING_INFO_NOT_AVAILABLE: i32 = -7;
pub const CL_MEM_COPY_OVERLAP: i32 = -8;
pub const CL_IMAGE_FORMAT_MISMATCH: i32 = -9;
pub const CL_IMAGE_FORMAT_NOT_SUPPORTED: i32 = -10;
pub const CL_BUILD_PROGRAM_FAILURE: i32 = -11;
pub const CL_MAP_FAILURE: i32 = -12;
pub const CL_MISALIGNED_SUB_BUFFER_OFFSET: i32 = -13;
pub const CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: i32 = -14;
pub const CL_COMPILE_PROGRAM_FAILURE: i32 = -15;
pub const CL_LINKER_NOT_AVAILABLE: i32 = -16;
pub const CL_LINK_PROGRAM_FAILURE: i32 = -17;
pub const CL_DEVICE_PARTITION_FAILED: i32 = -18;
pub const CL_KERNEL_ARG_INFO_NOT_AVAILABLE: i32 = -19;
pub const CL_INVALID_VALUE: i32 = -30;
pub const CL_INVALID_DEVICE_TYPE: i32 = -31;
pub const CL_INVALID_PLATFORM: i32 = -32;
pub const CL_INVALID_DEVICE: i32 = -33;
pub const CL_INVALID_CONTEXT: i32 = -34;
pub const CL_INVALID_QUEUE_PROPERTIES: i32 = -35;
pub const CL_INVALID_COMMAND_QUEUE: i32 = -36;
pub const CL_INVALID_HOST_PTR: i32 = -37;
pub const CL_INVALID_MEM_OBJECT: i32 = -38;
pub const CL_INVALID_IMAGE_FORMAT_DESCRIPTOR: i32 = -39;
pub const CL_INVALID_IMAGE_SIZE: i32 = -40;
pub const CL_INVALID_SAMPLER: i32 = -41;
pub const CL_INVALID_BINARY: i32 = -42;
pub const CL_INVALID_BUILD_OPTIONS: i32 = -43;
pub const CL_INVALID_PROGRAM: i32 = -44;
pub const CL_INVALID_PROGRAM_EXECUTABLE: i32 = -45;
pub const CL_INVALID_KERNEL_NAME: i32 = -46;
pub const CL_INVALID_KERNEL_DEFINITION: i32 = -47;
pub const CL_INVALID_KERNEL: i32 = -48;
pub const CL_INVALID_ARG_INDEX: i32 = -49;
pub const CL_INVALID_ARG_VALUE: i32 = -50;
pub const CL_INVALID_ARG_SIZE: i32 = -51;
pub const CL_INVALID_KERNEL_ARGS: i32 = -52;
pub const CL_INVALID_WORK_DIMENSION: i32 = -53;
pub const CL_INVALID_WORK_GROUP_SIZE: i32 = -54;
pub const CL_INVALID_WORK_ITEM_SIZE: i32 = -55;
pub const CL_INVALID_GLOBAL_OFFSET: i32 = -56;
pub const CL_INVALID_EVENT_WAIT_LIST: i32 = -57;
pub const CL_INVALID_EVENT: i32 = -58;
pub const CL_INVALID_OPERATION: i32 = -59;
pub const CL_INVALID_GL_OBJECT: i32 = -60;
pub const CL_INVALID_BUFFER_SIZE: i32 = -61;
pub const CL_INVALID_MIP_LEVEL: i32 = -62;
pub const CL_INVALID_GLOBAL_WORK_SIZE: i32 = -63;
pub const CL_INVALID_PROPERTY: i32 = -64;
pub const CL_INVALID_IMAGE_DESCRIPTOR: i32 = -65;
pub const CL_INVALID_COMPILER_OPTIONS: i32 = -66;
pub const CL_INVALID_LINKER_OPTIONS: i32 = -67;
pub const CL_INVALID_DEVICE_PARTITION_COUNT: i32 = -68;
pub const CL_FALSE: u32 = 0;
pub const CL_TRUE: u32 = 1;
pub const CL_BLOCKING: u32 = 1;
pub const CL_NON_BLOCKING: u32 = 0;
pub const CL_PLATFORM_PROFILE: u32 = 2304;
pub const CL_PLATFORM_VERSION: u32 = 2305;
pub const CL_PLATFORM_NAME: u32 = 2306;
pub const CL_PLATFORM_VENDOR: u32 = 2307;
pub const CL_PLATFORM_EXTENSIONS: u32 = 2308;
pub const CL_DEVICE_TYPE_DEFAULT: u32 = 1;
pub const CL_DEVICE_TYPE_CPU: u32 = 2;
pub const CL_DEVICE_TYPE_GPU: u32 = 4;
pub const CL_DEVICE_TYPE_ACCELERATOR: u32 = 8;
pub const CL_DEVICE_TYPE_CUSTOM: u32 = 16;
pub const CL_DEVICE_TYPE_ALL: u32 = 4294967295;
pub const CL_DEVICE_TYPE: u32 = 4096;
pub const CL_DEVICE_VENDOR_ID: u32 = 4097;
pub const CL_DEVICE_MAX_COMPUTE_UNITS: u32 = 4098;
pub const CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: u32 = 4099;
pub const CL_DEVICE_MAX_WORK_GROUP_SIZE: u32 = 4100;
pub const CL_DEVICE_MAX_WORK_ITEM_SIZES: u32 = 4101;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR: u32 = 4102;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT: u32 = 4103;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT: u32 = 4104;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG: u32 = 4105;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT: u32 = 4106;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE: u32 = 4107;
pub const CL_DEVICE_MAX_CLOCK_FREQUENCY: u32 = 4108;
pub const CL_DEVICE_ADDRESS_BITS: u32 = 4109;
pub const CL_DEVICE_MAX_READ_IMAGE_ARGS: u32 = 4110;
pub const CL_DEVICE_MAX_WRITE_IMAGE_ARGS: u32 = 4111;
pub const CL_DEVICE_MAX_MEM_ALLOC_SIZE: u32 = 4112;
pub const CL_DEVICE_IMAGE2D_MAX_WIDTH: u32 = 4113;
pub const CL_DEVICE_IMAGE2D_MAX_HEIGHT: u32 = 4114;
pub const CL_DEVICE_IMAGE3D_MAX_WIDTH: u32 = 4115;
pub const CL_DEVICE_IMAGE3D_MAX_HEIGHT: u32 = 4116;
pub const CL_DEVICE_IMAGE3D_MAX_DEPTH: u32 = 4117;
pub const CL_DEVICE_IMAGE_SUPPORT: u32 = 4118;
pub const CL_DEVICE_MAX_PARAMETER_SIZE: u32 = 4119;
pub const CL_DEVICE_MAX_SAMPLERS: u32 = 4120;
pub const CL_DEVICE_MEM_BASE_ADDR_ALIGN: u32 = 4121;
pub const CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE: u32 = 4122;
pub const CL_DEVICE_SINGLE_FP_CONFIG: u32 = 4123;
pub const CL_DEVICE_GLOBAL_MEM_CACHE_TYPE: u32 = 4124;
pub const CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE: u32 = 4125;
pub const CL_DEVICE_GLOBAL_MEM_CACHE_SIZE: u32 = 4126;
pub const CL_DEVICE_GLOBAL_MEM_SIZE: u32 = 4127;
pub const CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE: u32 = 4128;
pub const CL_DEVICE_MAX_CONSTANT_ARGS: u32 = 4129;
pub const CL_DEVICE_LOCAL_MEM_TYPE: u32 = 4130;
pub const CL_DEVICE_LOCAL_MEM_SIZE: u32 = 4131;
pub const CL_DEVICE_ERROR_CORRECTION_SUPPORT: u32 = 4132;
pub const CL_DEVICE_PROFILING_TIMER_RESOLUTION: u32 = 4133;
pub const CL_DEVICE_ENDIAN_LITTLE: u32 = 4134;
pub const CL_DEVICE_AVAILABLE: u32 = 4135;
pub const CL_DEVICE_COMPILER_AVAILABLE: u32 = 4136;
pub const CL_DEVICE_EXECUTION_CAPABILITIES: u32 = 4137;
pub const CL_DEVICE_QUEUE_PROPERTIES: u32 = 4138;
pub const CL_DEVICE_NAME: u32 = 4139;
pub const CL_DEVICE_VENDOR: u32 = 4140;
pub const CL_DRIVER_VERSION: u32 = 4141;
pub const CL_DEVICE_PROFILE: u32 = 4142;
pub const CL_DEVICE_VERSION: u32 = 4143;
pub const CL_DEVICE_EXTENSIONS: u32 = 4144;
pub const CL_DEVICE_PLATFORM: u32 = 4145;
pub const CL_DEVICE_DOUBLE_FP_CONFIG: u32 = 4146;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF: u32 = 4148;
pub const CL_DEVICE_HOST_UNIFIED_MEMORY: u32 = 4149;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR: u32 = 4150;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT: u32 = 4151;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_INT: u32 = 4152;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG: u32 = 4153;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT: u32 = 4154;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE: u32 = 4155;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF: u32 = 4156;
pub const CL_DEVICE_OPENCL_C_VERSION: u32 = 4157;
pub const CL_DEVICE_LINKER_AVAILABLE: u32 = 4158;
pub const CL_DEVICE_BUILT_IN_KERNELS: u32 = 4159;
pub const CL_DEVICE_IMAGE_MAX_BUFFER_SIZE: u32 = 4160;
pub const CL_DEVICE_IMAGE_MAX_ARRAY_SIZE: u32 = 4161;
pub const CL_DEVICE_PARENT_DEVICE: u32 = 4162;
pub const CL_DEVICE_PARTITION_MAX_SUB_DEVICES: u32 = 4163;
pub const CL_DEVICE_PARTITION_PROPERTIES: u32 = 4164;
pub const CL_DEVICE_PARTITION_AFFINITY_DOMAIN: u32 = 4165;
pub const CL_DEVICE_PARTITION_TYPE: u32 = 4166;
pub const CL_DEVICE_REFERENCE_COUNT: u32 = 4167;
pub const CL_DEVICE_PREFERRED_INTEROP_USER_SYNC: u32 = 4168;
pub const CL_DEVICE_PRINTF_BUFFER_SIZE: u32 = 4169;
pub const CL_FP_DENORM: u32 = 1;
pub const CL_FP_INF_NAN: u32 = 2;
pub const CL_FP_ROUND_TO_NEAREST: u32 = 4;
pub const CL_FP_ROUND_TO_ZERO: u32 = 8;
pub const CL_FP_ROUND_TO_INF: u32 = 16;
pub const CL_FP_FMA: u32 = 32;
pub const CL_FP_SOFT_FLOAT: u32 = 64;
pub const CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT: u32 = 128;
pub const CL_NONE: u32 = 0;
pub const CL_READ_ONLY_CACHE: u32 = 1;
pub const CL_READ_WRITE_CACHE: u32 = 2;
pub const CL_LOCAL: u32 = 1;
pub const CL_GLOBAL: u32 = 2;
pub const CL_EXEC_KERNEL: u32 = 1;
pub const CL_EXEC_NATIVE_KERNEL: u32 = 2;
pub const CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE: u32 = 1;
pub const CL_QUEUE_PROFILING_ENABLE: u32 = 2;
pub const CL_CONTEXT_REFERENCE_COUNT: u32 = 4224;
pub const CL_CONTEXT_DEVICES: u32 = 4225;
pub const CL_CONTEXT_PROPERTIES: u32 = 4226;
pub const CL_CONTEXT_NUM_DEVICES: u32 = 4227;
pub const CL_CONTEXT_PLATFORM: u32 = 4228;
pub const CL_CONTEXT_INTEROP_USER_SYNC: u32 = 4229;
pub const CL_DEVICE_PARTITION_EQUALLY: u32 = 4230;
pub const CL_DEVICE_PARTITION_BY_COUNTS: u32 = 4231;
pub const CL_DEVICE_PARTITION_BY_COUNTS_LIST_END: u32 = 0;
pub const CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN: u32 = 4232;
pub const CL_DEVICE_AFFINITY_DOMAIN_NUMA: u32 = 1;
pub const CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE: u32 = 2;
pub const CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE: u32 = 4;
pub const CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE: u32 = 8;
pub const CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE: u32 = 16;
pub const CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE: u32 = 32;
pub const CL_QUEUE_CONTEXT: u32 = 4240;
pub const CL_QUEUE_DEVICE: u32 = 4241;
pub const CL_QUEUE_REFERENCE_COUNT: u32 = 4242;
pub const CL_QUEUE_PROPERTIES: u32 = 4243;
pub const CL_MEM_READ_WRITE: u32 = 1;
pub const CL_MEM_WRITE_ONLY: u32 = 2;
pub const CL_MEM_READ_ONLY: u32 = 4;
pub const CL_MEM_USE_HOST_PTR: u32 = 8;
pub const CL_MEM_ALLOC_HOST_PTR: u32 = 16;
pub const CL_MEM_COPY_HOST_PTR: u32 = 32;
pub const CL_MEM_HOST_WRITE_ONLY: u32 = 128;
pub const CL_MEM_HOST_READ_ONLY: u32 = 256;
pub const CL_MEM_HOST_NO_ACCESS: u32 = 512;
pub const CL_MIGRATE_MEM_OBJECT_HOST: u32 = 1;
pub const CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED: u32 = 2;
pub const CL_R: u32 = 4272;
pub const CL_A: u32 = 4273;
pub const CL_RG: u32 = 4274;
pub const CL_RA: u32 = 4275;
pub const CL_RGB: u32 = 4276;
pub const CL_RGBA: u32 = 4277;
pub const CL_BGRA: u32 = 4278;
pub const CL_ARGB: u32 = 4279;
pub const CL_INTENSITY: u32 = 4280;
pub const CL_LUMINANCE: u32 = 4281;
pub const CL_Rx: u32 = 4282;
pub const CL_RGx: u32 = 4283;
pub const CL_RGBx: u32 = 4284;
pub const CL_SNORM_INT8: u32 = 4304;
pub const CL_SNORM_INT16: u32 = 4305;
pub const CL_UNORM_INT8: u32 = 4306;
pub const CL_UNORM_INT16: u32 = 4307;
pub const CL_UNORM_SHORT_565: u32 = 4308;
pub const CL_UNORM_SHORT_555: u32 = 4309;
pub const CL_UNORM_INT_101010: u32 = 4310;
pub const CL_SIGNED_INT8: u32 = 4311;
pub const CL_SIGNED_INT16: u32 = 4312;
pub const CL_SIGNED_INT32: u32 = 4313;
pub const CL_UNSIGNED_INT8: u32 = 4314;
pub const CL_UNSIGNED_INT16: u32 = 4315;
pub const CL_UNSIGNED_INT32: u32 = 4316;
pub const CL_HALF_FLOAT: u32 = 4317;
pub const CL_FLOAT: u32 = 4318;
pub const CL_MEM_OBJECT_BUFFER: u32 = 4336;
pub const CL_MEM_OBJECT_IMAGE2D: u32 = 4337;
pub const CL_MEM_OBJECT_IMAGE3D: u32 = 4338;
pub const CL_MEM_OBJECT_IMAGE2D_ARRAY: u32 = 4339;
pub const CL_MEM_OBJECT_IMAGE1D: u32 = 4340;
pub const CL_MEM_OBJECT_IMAGE1D_ARRAY: u32 = 4341;
pub const CL_MEM_OBJECT_IMAGE1D_BUFFER: u32 = 4342;
pub const CL_MEM_TYPE: u32 = 4352;
pub const CL_MEM_FLAGS: u32 = 4353;
pub const CL_MEM_SIZE: u32 = 4354;
pub const CL_MEM_HOST_PTR: u32 = 4355;
pub const CL_MEM_MAP_COUNT: u32 = 4356;
pub const CL_MEM_REFERENCE_COUNT: u32 = 4357;
pub const CL_MEM_CONTEXT: u32 = 4358;
pub const CL_MEM_ASSOCIATED_MEMOBJECT: u32 = 4359;
pub const CL_MEM_OFFSET: u32 = 4360;
pub const CL_IMAGE_FORMAT: u32 = 4368;
pub const CL_IMAGE_ELEMENT_SIZE: u32 = 4369;
pub const CL_IMAGE_ROW_PITCH: u32 = 4370;
pub const CL_IMAGE_SLICE_PITCH: u32 = 4371;
pub const CL_IMAGE_WIDTH: u32 = 4372;
pub const CL_IMAGE_HEIGHT: u32 = 4373;
pub const CL_IMAGE_DEPTH: u32 = 4374;
pub const CL_IMAGE_ARRAY_SIZE: u32 = 4375;
pub const CL_IMAGE_BUFFER: u32 = 4376;
pub const CL_IMAGE_NUM_MIP_LEVELS: u32 = 4377;
pub const CL_IMAGE_NUM_SAMPLES: u32 = 4378;
pub const CL_ADDRESS_NONE: u32 = 4400;
pub const CL_ADDRESS_CLAMP_TO_EDGE: u32 = 4401;
pub const CL_ADDRESS_CLAMP: u32 = 4402;
pub const CL_ADDRESS_REPEAT: u32 = 4403;
pub const CL_ADDRESS_MIRRORED_REPEAT: u32 = 4404;
pub const CL_FILTER_NEAREST: u32 = 4416;
pub const CL_FILTER_LINEAR: u32 = 4417;
pub const CL_SAMPLER_REFERENCE_COUNT: u32 = 4432;
pub const CL_SAMPLER_CONTEXT: u32 = 4433;
pub const CL_SAMPLER_NORMALIZED_COORDS: u32 = 4434;
pub const CL_SAMPLER_ADDRESSING_MODE: u32 = 4435;
pub const CL_SAMPLER_FILTER_MODE: u32 = 4436;
pub const CL_MAP_READ: u32 = 1;
pub const CL_MAP_WRITE: u32 = 2;
pub const CL_MAP_WRITE_INVALIDATE_REGION: u32 = 4;
pub const CL_PROGRAM_REFERENCE_COUNT: u32 = 4448;
pub const CL_PROGRAM_CONTEXT: u32 = 4449;
pub const CL_PROGRAM_NUM_DEVICES: u32 = 4450;
pub const CL_PROGRAM_DEVICES: u32 = 4451;
pub const CL_PROGRAM_SOURCE: u32 = 4452;
pub const CL_PROGRAM_BINARY_SIZES: u32 = 4453;
pub const CL_PROGRAM_BINARIES: u32 = 4454;
pub const CL_PROGRAM_NUM_KERNELS: u32 = 4455;
pub const CL_PROGRAM_KERNEL_NAMES: u32 = 4456;
pub const CL_PROGRAM_BUILD_STATUS: u32 = 4481;
pub const CL_PROGRAM_BUILD_OPTIONS: u32 = 4482;
pub const CL_PROGRAM_BUILD_LOG: u32 = 4483;
pub const CL_PROGRAM_BINARY_TYPE: u32 = 4484;
pub const CL_PROGRAM_BINARY_TYPE_NONE: u32 = 0;
pub const CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT: u32 = 1;
pub const CL_PROGRAM_BINARY_TYPE_LIBRARY: u32 = 2;
pub const CL_PROGRAM_BINARY_TYPE_EXECUTABLE: u32 = 4;
pub const CL_BUILD_SUCCESS: u32 = 0;
pub const CL_BUILD_NONE: i32 = -1;
pub const CL_BUILD_ERROR: i32 = -2;
pub const CL_BUILD_IN_PROGRESS: i32 = -3;
pub const CL_KERNEL_FUNCTION_NAME: u32 = 4496;
pub const CL_KERNEL_NUM_ARGS: u32 = 4497;
pub const CL_KERNEL_REFERENCE_COUNT: u32 = 4498;
pub const CL_KERNEL_CONTEXT: u32 = 4499;
pub const CL_KERNEL_PROGRAM: u32 = 4500;
pub const CL_KERNEL_ATTRIBUTES: u32 = 4501;
pub const CL_KERNEL_ARG_ADDRESS_QUALIFIER: u32 = 4502;
pub const CL_KERNEL_ARG_ACCESS_QUALIFIER: u32 = 4503;
pub const CL_KERNEL_ARG_TYPE_NAME: u32 = 4504;
pub const CL_KERNEL_ARG_TYPE_QUALIFIER: u32 = 4505;
pub const CL_KERNEL_ARG_NAME: u32 = 4506;
pub const CL_KERNEL_ARG_ADDRESS_GLOBAL: u32 = 4507;
pub const CL_KERNEL_ARG_ADDRESS_LOCAL: u32 = 4508;
pub const CL_KERNEL_ARG_ADDRESS_CONSTANT: u32 = 4509;
pub const CL_KERNEL_ARG_ADDRESS_PRIVATE: u32 = 4510;
pub const CL_KERNEL_ARG_ACCESS_READ_ONLY: u32 = 4512;
pub const CL_KERNEL_ARG_ACCESS_WRITE_ONLY: u32 = 4513;
pub const CL_KERNEL_ARG_ACCESS_READ_WRITE: u32 = 4514;
pub const CL_KERNEL_ARG_ACCESS_NONE: u32 = 4515;
pub const CL_KERNEL_ARG_TYPE_NONE: u32 = 0;
pub const CL_KERNEL_ARG_TYPE_CONST: u32 = 1;
pub const CL_KERNEL_ARG_TYPE_RESTRICT: u32 = 2;
pub const CL_KERNEL_ARG_TYPE_VOLATILE: u32 = 4;
pub const CL_KERNEL_WORK_GROUP_SIZE: u32 = 4528;
pub const CL_KERNEL_COMPILE_WORK_GROUP_SIZE: u32 = 4529;
pub const CL_KERNEL_LOCAL_MEM_SIZE: u32 = 4530;
pub const CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE: u32 = 4531;
pub const CL_KERNEL_PRIVATE_MEM_SIZE: u32 = 4532;
pub const CL_KERNEL_GLOBAL_WORK_SIZE: u32 = 4533;
pub const CL_EVENT_COMMAND_QUEUE: u32 = 4560;
pub const CL_EVENT_COMMAND_TYPE: u32 = 4561;
pub const CL_EVENT_REFERENCE_COUNT: u32 = 4562;
pub const CL_EVENT_COMMAND_EXECUTION_STATUS: u32 = 4563;
pub const CL_EVENT_CONTEXT: u32 = 4564;
pub const CL_COMMAND_NDRANGE_KERNEL: u32 = 4592;
pub const CL_COMMAND_TASK: u32 = 4593;
pub const CL_COMMAND_NATIVE_KERNEL: u32 = 4594;
pub const CL_COMMAND_READ_BUFFER: u32 = 4595;
pub const CL_COMMAND_WRITE_BUFFER: u32 = 4596;
pub const CL_COMMAND_COPY_BUFFER: u32 = 4597;
pub const CL_COMMAND_READ_IMAGE: u32 = 4598;
pub const CL_COMMAND_WRITE_IMAGE: u32 = 4599;
pub const CL_COMMAND_COPY_IMAGE: u32 = 4600;
pub const CL_COMMAND_COPY_IMAGE_TO_BUFFER: u32 = 4601;
pub const CL_COMMAND_COPY_BUFFER_TO_IMAGE: u32 = 4602;
pub const CL_COMMAND_MAP_BUFFER: u32 = 4603;
pub const CL_COMMAND_MAP_IMAGE: u32 = 4604;
pub const CL_COMMAND_UNMAP_MEM_OBJECT: u32 = 4605;
pub const CL_COMMAND_MARKER: u32 = 4606;
pub const CL_COMMAND_ACQUIRE_GL_OBJECTS: u32 = 4607;
pub const CL_COMMAND_RELEASE_GL_OBJECTS: u32 = 4608;
pub const CL_COMMAND_READ_BUFFER_RECT: u32 = 4609;
pub const CL_COMMAND_WRITE_BUFFER_RECT: u32 = 4610;
pub const CL_COMMAND_COPY_BUFFER_RECT: u32 = 4611;
pub const CL_COMMAND_USER: u32 = 4612;
pub const CL_COMMAND_BARRIER: u32 = 4613;
pub const CL_COMMAND_MIGRATE_MEM_OBJECTS: u32 = 4614;
pub const CL_COMMAND_FILL_BUFFER: u32 = 4615;
pub const CL_COMMAND_FILL_IMAGE: u32 = 4616;
pub const CL_COMPLETE: u32 = 0;
pub const CL_RUNNING: u32 = 1;
pub const CL_SUBMITTED: u32 = 2;
pub const CL_QUEUED: u32 = 3;
pub const CL_BUFFER_CREATE_TYPE_REGION: u32 = 4640;
pub const CL_PROFILING_COMMAND_QUEUED: u32 = 4736;
pub const CL_PROFILING_COMMAND_SUBMIT: u32 = 4737;
pub const CL_PROFILING_COMMAND_START: u32 = 4738;
pub const CL_PROFILING_COMMAND_END: u32 = 4739;
pub const CL_KHRONOS_VENDOR_ID_CODEPLAY: u32 = 65540;
pub mod dnnl_ocl_interop_memory_kind_t {
    #[doc = " Memory allocation kind."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " USM (device, shared, host, or unknown) memory allocation kind."]
    pub const dnnl_ocl_interop_usm: Type = 0;
    #[doc = " Buffer memory allocation kind - default."]
    pub const dnnl_ocl_interop_buffer: Type = 1;
}
pub type cl_int = i32;
pub type cl_uint = u32;
pub type cl_ulong = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_platform_id {
    _unused: [u8; 0],
}
pub type cl_platform_id = *mut _cl_platform_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_device_id {
    _unused: [u8; 0],
}
pub type cl_device_id = *mut _cl_device_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_context {
    _unused: [u8; 0],
}
pub type cl_context = *mut _cl_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_command_queue {
    _unused: [u8; 0],
}
pub type cl_command_queue = *mut _cl_command_queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_mem {
    _unused: [u8; 0],
}
pub type cl_mem = *mut _cl_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_event {
    _unused: [u8; 0],
}
pub type cl_event = *mut _cl_event;
pub type cl_bool = cl_uint;
pub type cl_bitfield = cl_ulong;
pub type cl_device_type = cl_bitfield;
pub type cl_platform_info = cl_uint;
pub type cl_device_info = cl_uint;
pub type cl_command_queue_properties = cl_bitfield;
pub type cl_context_properties = isize;
pub type cl_channel_order = cl_uint;
pub type cl_channel_type = cl_uint;
pub type cl_mem_flags = cl_bitfield;
pub type cl_buffer_create_type = cl_uint;
pub type cl_map_flags = cl_bitfield;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_image_format {
    pub image_channel_order: cl_channel_order,
    pub image_channel_data_type: cl_channel_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _cl_image_format"][::std::mem::size_of::<_cl_image_format>() - 8usize];
    ["Alignment of _cl_image_format"][::std::mem::align_of::<_cl_image_format>() - 4usize];
    ["Offset of field: _cl_image_format::image_channel_order"]
        [::std::mem::offset_of!(_cl_image_format, image_channel_order) - 0usize];
    ["Offset of field: _cl_image_format::image_channel_data_type"]
        [::std::mem::offset_of!(_cl_image_format, image_channel_data_type) - 4usize];
};
pub type cl_image_format = _cl_image_format;
unsafe extern "C" {
    pub fn clGetPlatformIDs(
        num_entries: cl_uint,
        platforms: *mut cl_platform_id,
        num_platforms: *mut cl_uint,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clGetPlatformInfo(
        platform: cl_platform_id,
        param_name: cl_platform_info,
        param_value_size: usize,
        param_value: *mut ::std::os::raw::c_void,
        param_value_size_ret: *mut usize,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clGetDeviceIDs(
        platform: cl_platform_id,
        device_type: cl_device_type,
        num_entries: cl_uint,
        devices: *mut cl_device_id,
        num_devices: *mut cl_uint,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clGetDeviceInfo(
        device: cl_device_id,
        param_name: cl_device_info,
        param_value_size: usize,
        param_value: *mut ::std::os::raw::c_void,
        param_value_size_ret: *mut usize,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clCreateContext(
        properties: *const cl_context_properties,
        num_devices: cl_uint,
        devices: *const cl_device_id,
        pfn_notify: ::std::option::Option<
            unsafe extern "C" fn(
                errinfo: *const ::std::os::raw::c_char,
                private_info: *const ::std::os::raw::c_void,
                cb: usize,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
        errcode_ret: *mut cl_int,
    ) -> cl_context;
}
unsafe extern "C" {
    pub fn clRetainContext(context: cl_context) -> cl_int;
}
unsafe extern "C" {
    pub fn clReleaseContext(context: cl_context) -> cl_int;
}
unsafe extern "C" {
    pub fn clRetainCommandQueue(command_queue: cl_command_queue) -> cl_int;
}
unsafe extern "C" {
    pub fn clReleaseCommandQueue(command_queue: cl_command_queue) -> cl_int;
}
unsafe extern "C" {
    pub fn clCreateBuffer(
        context: cl_context,
        flags: cl_mem_flags,
        size: usize,
        host_ptr: *mut ::std::os::raw::c_void,
        errcode_ret: *mut cl_int,
    ) -> cl_mem;
}
unsafe extern "C" {
    pub fn clCreateSubBuffer(
        buffer: cl_mem,
        flags: cl_mem_flags,
        buffer_create_type: cl_buffer_create_type,
        buffer_create_info: *const ::std::os::raw::c_void,
        errcode_ret: *mut cl_int,
    ) -> cl_mem;
}
unsafe extern "C" {
    pub fn clEnqueueReadBuffer(
        command_queue: cl_command_queue,
        buffer: cl_mem,
        blocking_read: cl_bool,
        offset: usize,
        size: usize,
        ptr: *mut ::std::os::raw::c_void,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clEnqueueWriteBuffer(
        command_queue: cl_command_queue,
        buffer: cl_mem,
        blocking_write: cl_bool,
        offset: usize,
        size: usize,
        ptr: *const ::std::os::raw::c_void,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clEnqueueFillBuffer(
        command_queue: cl_command_queue,
        buffer: cl_mem,
        pattern: *const ::std::os::raw::c_void,
        pattern_size: usize,
        offset: usize,
        size: usize,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clEnqueueCopyBuffer(
        command_queue: cl_command_queue,
        src_buffer: cl_mem,
        dst_buffer: cl_mem,
        src_offset: usize,
        dst_offset: usize,
        size: usize,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clEnqueueCopyImageToBuffer(
        command_queue: cl_command_queue,
        src_image: cl_mem,
        dst_buffer: cl_mem,
        src_origin: *const usize,
        region: *const usize,
        dst_offset: usize,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
    ) -> cl_int;
}
unsafe extern "C" {
    pub fn clEnqueueMapBuffer(
        command_queue: cl_command_queue,
        buffer: cl_mem,
        blocking_map: cl_bool,
        map_flags: cl_map_flags,
        offset: usize,
        size: usize,
        num_events_in_wait_list: cl_uint,
        event_wait_list: *const cl_event,
        event: *mut cl_event,
        errcode_ret: *mut cl_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clCreateImage2D(
        context: cl_context,
        flags: cl_mem_flags,
        image_format: *const cl_image_format,
        image_width: usize,
        image_height: usize,
        image_row_pitch: usize,
        host_ptr: *mut ::std::os::raw::c_void,
        errcode_ret: *mut cl_int,
    ) -> cl_mem;
}
unsafe extern "C" {
    pub fn clCreateImage3D(
        context: cl_context,
        flags: cl_mem_flags,
        image_format: *const cl_image_format,
        image_width: usize,
        image_height: usize,
        image_depth: usize,
        image_row_pitch: usize,
        image_slice_pitch: usize,
        host_ptr: *mut ::std::os::raw::c_void,
        errcode_ret: *mut cl_int,
    ) -> cl_mem;
}
unsafe extern "C" {
    pub fn clCreateCommandQueue(
        context: cl_context,
        device: cl_device_id,
        properties: cl_command_queue_properties,
        errcode_ret: *mut cl_int,
    ) -> cl_command_queue;
}
unsafe extern "C" {
    #[doc = " Creates a memory object.\n\n Unless @p handle is equal to DNNL_MEMORY_NONE or DNNL_MEMORY_ALLOCATE, the\n constructed memory object will have the underlying buffer set. In this\n case, the buffer will be initialized as if:\n - dnnl_memory_set_data_handle() has been called, if @p memory_kind is equal\n   to dnnl_ocl_interop_usm, or\n - dnnl_ocl_interop_memory_set_mem_object() has been called, if @p memory_kind\n   is equal to dnnl_ocl_interop_buffer.\n\n @param memory Output memory object.\n @param memory_desc Memory descriptor.\n @param engine Engine to use.\n @param memory_kind Memory allocation kind to specify the type of handle.\n @param handle Handle of the memory buffer to use as an underlying storage.\n     - A USM pointer to the user-allocated buffer. In this case the library\n       doesn't own the buffer. Requires @p memory_kind to be equal to\n       dnnl_ocl_interop_usm.\n     - An OpenCL buffer. In this case the library doesn't own the buffer.\n       Requires @p memory_kind be equal to be equal to dnnl_ocl_interop_buffer.\n     - The DNNL_MEMORY_ALLOCATE special value. Instructs the library to\n       allocate the buffer that corresponds to the memory allocation kind\n       @p memory_kind for the memory object. In this case the library\n       owns the buffer.\n     - The DNNL_MEMORY_NONE specific value. Instructs the library to\n       create memory object without an underlying buffer.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_memory_create(
        memory: *mut dnnl_memory_t,
        memory_desc: const_dnnl_memory_desc_t,
        engine: dnnl_engine_t,
        memory_kind: dnnl_ocl_interop_memory_kind_t::Type,
        handle: *mut ::std::os::raw::c_void,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Returns the memory allocation kind associated with a memory object.\n\n @param memory Memory to query.\n @param memory_kind Output underlying memory allocation kind of the memory\n     object.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_memory_get_memory_kind(
        memory: const_dnnl_memory_t,
        memory_kind: *mut dnnl_ocl_interop_memory_kind_t::Type,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Returns an OpenCL memory object associated with a memory object.\n\n @param memory Memory object.\n @param mem_object Output OpenCL memory object.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_memory_get_mem_object(
        memory: const_dnnl_memory_t,
        mem_object: *mut cl_mem,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Sets OpenCL memory object associated with a memory object.\n\n For behavioral details, see dnnl_memory_set_data_handle().\n\n @param memory Memory object.\n @param mem_object OpenCL memory object.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_memory_set_mem_object(
        memory: dnnl_memory_t,
        mem_object: cl_mem,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Retrieves a cache blob ID for the OpenCL device.\n\n @warning\n     This API is intended to be used with\n     #dnnl_ocl_interop_engine_get_cache_blob() and\n     #dnnl_ocl_interop_engine_create_from_cache_blob(). The returned cache\n     blob ID can only be used as an ID of the cache blob returned by\n     #dnnl_ocl_interop_engine_get_cache_blob().\n\n @note The cache blob ID can be empty (@p size will be 0 and\n     @p cache_blob_id will be nullptr) if oneDNN doesn't have anything to\n     put in the cache blob. (#dnnl_ocl_interop_engine_get_cache_blob will\n     return an empty cache blob).\n\n @param device An OpenCL device.\n @param size Size of the cache blob ID in bytes.\n @param cache_blob_id Cache blob id of size @p size. If\n     the @p cache_blob_id is nullptr then the size of the cache blob ID is\n     returned in @p size.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_engine_get_cache_blob_id(
        device: cl_device_id,
        size: *mut usize,
        cache_blob_id: *mut u8,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Retrieves a cache blob associated with the given engine.\n\n @note The cache blob can be empty (@p size will be 0 and @p cache_blob\n     will be nullptr) if oneDNN doesn't have anything to put in the cache\n     blob. It's the user's responsibility to check whether it's empty\n     prior to passing it to\n     #dnnl_ocl_interop_engine_create_from_cache_blob().\n\n @param engine Engine to query for the cache blob.\n @param size Size of the cache blob in bytes.\n @param cache_blob Cache blob of size @p size. If the @p cache_blob is\n     nullptr then the size of the cache blob is returned in @p size.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_engine_get_cache_blob(
        engine: dnnl_engine_t,
        size: *mut usize,
        cache_blob: *mut u8,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Creates an engine from the given cache blob.\n\n @param engine Output engine.\n @param device The OpenCL device that this engine will encapsulate.\n @param context The OpenCL context (containing the device) that this\n     engine will use for all operations.\n @param size Size of the cache blob in bytes.\n @param cache_blob Cache blob of size @p size.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_engine_create_from_cache_blob(
        engine: *mut dnnl_engine_t,
        device: cl_device_id,
        context: cl_context,
        size: usize,
        cache_blob: *const u8,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Creates an engine associated with an OpenCL device and an OpenCL context.\n\n @param engine Output engine.\n @param device Underlying OpenCL device to use for the engine.\n @param context Underlying OpenCL context to use for the engine.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_engine_create(
        engine: *mut dnnl_engine_t,
        device: cl_device_id,
        context: cl_context,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Returns the OpenCL context associated with an engine.\n\n @param engine Engine to query.\n @param context Output underlying OpenCL context of the engine.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_engine_get_context(
        engine: dnnl_engine_t,
        context: *mut cl_context,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Returns the OpenCL device associated with an engine.\n\n @param engine Engine to query.\n @param device Output underlying OpenCL device of the engine.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_get_device(
        engine: dnnl_engine_t,
        device: *mut cl_device_id,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Creates an execution stream for a given engine associated with\n an OpenCL command queue.\n\n @param stream Output execution stream.\n @param engine Engine to create the execution stream on.\n @param queue OpenCL command queue to use.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_stream_create(
        stream: *mut dnnl_stream_t,
        engine: dnnl_engine_t,
        queue: cl_command_queue,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Returns the OpenCL command queue associated with an execution stream.\n\n @param stream Execution stream to query.\n @param queue Output OpenCL command queue.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_stream_get_command_queue(
        stream: dnnl_stream_t,
        queue: *mut cl_command_queue,
    ) -> dnnl_status_t::Type;
}
unsafe extern "C" {
    #[doc = " Executes computations specified by the primitive in a specified stream and\n returns an OpenCL event.\n\n @param primitive Primitive to execute.\n @param stream Stream to use.\n @param nargs Number of arguments.\n @param args Array of arguments. Each argument is an\n     <index, #dnnl_memory_t> pair. The index is one of the `DNNL_ARG_*`\n     values such as `DNNL_ARG_SRC`. Unless runtime shapes are used (see\n     #DNNL_RUNTIME_DIM_VAL), the memory object must have the same memory\n     descriptor as that returned by\n     #dnnl_primitive_desc_query_md(#dnnl_query_exec_arg_md, index).\n @param deps A pointer to a vector of size @p ndeps that contains\n     dependencies.\n @param ndeps Number of dependencies.\n @param return_event Output event. It's the user's responsibility to\n     manage lifetime of the event. Can be NULL. When @p stream is in-order\n     NULL will be returned.\n @returns #dnnl_success on success and a status describing the error\n     otherwise."]
    pub fn dnnl_ocl_interop_primitive_execute(
        primitive: const_dnnl_primitive_t,
        stream: dnnl_stream_t,
        nargs: ::std::os::raw::c_int,
        args: *const dnnl_exec_arg_t,
        deps: *const cl_event,
        ndeps: ::std::os::raw::c_int,
        return_event: *mut cl_event,
    ) -> dnnl_status_t::Type;
}
